<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Adding meta -->
    

    <!-- Adding external script-->
    

    <!-- Adding external style-->
    

    <!-- Adding scripts-->
    

    <!-- Adding style-->
    

    <!-- Adding overlay script-->
    

    <!-- Adding overlay style-->
    


    <title>Grid.js</title>

    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/third-party/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/third-party/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme-base.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme-light.css">
    
<svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="display:none">
    <defs>
        <symbol id="copy-icon" viewbox="0 0 488.3 488.3">
            <g>
                <path d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z"/>
                <path d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z"/>
            </g>
        </symbol>
    </defs>
</svg>

</head>
<body>
<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html"><div class="text">Home</div></a></h2><div class="search-box"><input type="text" placeholder="Search..." id="search-box" /><div class="search-item-container" id="search-item-container"><ul class="search-item-ul" id="search-item-ul"></ul></div></div><div class="sidebar-list-div"><h3>Classes</h3><ul><li class="accordion collapsed" id=15865><div class="accordion-title"><a href="Grid.html">Grid</a><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16">
    <path 
        fill-rule="evenodd" 
        clip-rule="evenodd" 
        d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z">
    </path>
</svg></div><ul class='methods accordion-content'><li data-type='method'><a href="Grid.html#addObjectToGrid">addObjectToGrid</a></li><li data-type='method'><a href="Grid.html#addRangeWalls">addRangeWalls</a></li><li data-type='method'><a href="Grid.html#addTileWall">addTileWall</a></li><li data-type='method'><a href="Grid.html#addWall">addWall</a></li><li data-type='method'><a href="Grid.html#addWallRange">addWallRange</a></li><li data-type='method'><a href="Grid.html#AStarSearch">AStarSearch</a></li><li data-type='method'><a href="Grid.html#changeObjectPosition">changeObjectPosition</a></li><li data-type='method'><a href="Grid.html#draw">draw</a></li><li data-type='method'><a href="Grid.html#editRangeCollision">editRangeCollision</a></li><li data-type='method'><a href="Grid.html#editRangeTexture">editRangeTexture</a></li><li data-type='method'><a href="Grid.html#editRangeVisible">editRangeVisible</a></li><li data-type='method'><a href="Grid.html#editTileCollision">editTileCollision</a></li><li data-type='method'><a href="Grid.html#editTileTexture">editTileTexture</a></li><li data-type='method'><a href="Grid.html#editTileVisible">editTileVisible</a></li><li data-type='method'><a href="Grid.html#getIDPosition">getIDPosition</a></li><li data-type='method'><a href="Grid.html#getNeighbors">getNeighbors</a></li><li data-type='method'><a href="Grid.html#getTileAtIndex">getTileAtIndex</a></li><li data-type='method'><a href="Grid.html#getTileAtWC">getTileAtWC</a></li><li data-type='method'><a href="Grid.html#getTileHeight">getTileHeight</a></li><li data-type='method'><a href="Grid.html#getTileWidth">getTileWidth</a></li><li data-type='method'><a href="Grid.html#isWCValidInGrid">isWCValidInGrid</a></li><li data-type='method'><a href="Grid.html#manhattanDistance">manhattanDistance</a></li><li data-type='method'><a href="Grid.html#moveObjectPositionDir">moveObjectPositionDir</a></li><li data-type='method'><a href="Grid.html#readySearch">readySearch</a></li><li data-type='method'><a href="Grid.html#removeObjectFromGrid">removeObjectFromGrid</a></li><li data-type='method'><a href="Grid.html#removeTileWall">removeTileWall</a></li><li data-type='method'><a href="Grid.html#removeWallRange">removeWallRange</a></li><li data-type='method'><a href="Grid.html#setVisualizeEdges">setVisualizeEdges</a></li></ul></li><li class="accordion collapsed" id=2122570><div class="accordion-title"><a href="Tile.html">Tile</a><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16">
    <path 
        fill-rule="evenodd" 
        clip-rule="evenodd" 
        d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z">
    </path>
</svg></div><ul class='methods accordion-content'><li data-type='method'><a href="Tile.html#addWall">addWall</a></li><li data-type='method'><a href="Tile.html#draw">draw</a></li><li data-type='method'><a href="Tile.html#getC">getC</a></li><li data-type='method'><a href="Tile.html#getCollision">getCollision</a></li><li data-type='method'><a href="Tile.html#getD">getD</a></li><li data-type='method'><a href="Tile.html#getF">getF</a></li><li data-type='method'><a href="Tile.html#getH">getH</a></li><li data-type='method'><a href="Tile.html#getMoves">getMoves</a></li><li data-type='method'><a href="Tile.html#getP">getP</a></li><li data-type='method'><a href="Tile.html#getWalls">getWalls</a></li><li data-type='method'><a href="Tile.html#getXPosWC">getXPosWC</a></li><li data-type='method'><a href="Tile.html#getYPosWC">getYPosWC</a></li><li data-type='method'><a href="Tile.html#hasP">hasP</a></li><li data-type='method'><a href="Tile.html#isVisible">isVisible</a></li><li data-type='method'><a href="Tile.html#readySearch">readySearch</a></li><li data-type='method'><a href="Tile.html#removeWall">removeWall</a></li><li data-type='method'><a href="Tile.html#setC">setC</a></li><li data-type='method'><a href="Tile.html#setCollision">setCollision</a></li><li data-type='method'><a href="Tile.html#setD">setD</a></li><li data-type='method'><a href="Tile.html#setGridLineVisibility">setGridLineVisibility</a></li><li data-type='method'><a href="Tile.html#setH">setH</a></li><li data-type='method'><a href="Tile.html#setP">setP</a></li><li data-type='method'><a href="Tile.html#setTexture">setTexture</a></li><li data-type='method'><a href="Tile.html#setVisible">setVisible</a></li><li data-type='method'><a href="Tile.html#setWallVisibility">setWallVisibility</a></li></ul></li></ul>


<h3><a href="tutorial.html">Tutorial</a></h3>
<h3><a href="demo/Dekema_Hannez_Grid_API/public_html/index.html">Demo</a></h3>


</div>
</nav>

<div id="main">
    
    <h1 id='page-title' class="page-title">Grid.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Represents a Grid object.
 * @constructor
 * @param {number} gridW - The width of the grid in number of tiles.
 * @param {number} gridH - The height of the grid in number of tiles.
 * @param {number} gridX - The x coordinate of the center of the grid in WC.
 * @param {number} gridY - The y coordinate of the center of the grid in WC.
 * @param {number} tileW - The width of each tile in WC.
 * @param {number} tileH - The height of each tile in WC.
 */
function Grid(gridW, gridH, gridX, gridY, tileW, tileH) {
    this.mTiles = []; // This array will be filled with array objects of tiles
    this.mTileW = tileW;
    this.mTileH = tileH;

    this.mGridW  = gridW;
    this.mGridH = gridH;
    this.mGridX = gridX;
    this.mGridY = gridY;

    // Track objects that have been given to the Grid to control movement of.
    this.mObjects = [];

    // Filling grid with tile object in grid dimensions given. May move to another func.
    for (var i = 0; i &lt; gridH; i++) { // Col loop
      var row = [];
      for (var j = 0; j &lt; gridW; j++) { // Row loop
        var tilex = (gridX - (tileW * Math.floor(gridW / 2))) + (j * tileW);
        var tiley = (gridY - (tileH * Math.floor(gridH / 2))) + (i * tileH);
        var isEdge = false;
        // Even case for X; offset
        if (gridW % 2 === 0) { 
          tilex = tilex + (tileW / 2);
        }
        // Even case for Y; offset
        if (gridH % 2 === 0) { 
          tiley = tiley + (tileH / 2);
        }
        // Tile is an edge tile; Mark it as such.
        if (i === (gridH - 1) || i === 0 || j === (gridW - 1) || j === 0) {
          isEdge = true;
        }
        row.push(new Tile(tileW, tileH, tilex, tiley, isEdge));
      }
      this.mTiles.push(row);
    }

    // add walls to the edges of the table
    // for prototyping purposes
    for (var i = 0; i &lt; this.mGridW; i++) {
        this.mTiles[0][i].addWall([0, -1]); // add wall to bottom
        this.mTiles[this.mGridH - 1][i].addWall([0, 1]); // add wall to top
    }
    
    for (var i = 0; i &lt; this.mGridH; i++) {
        this.mTiles[i][0].addWall([-1, 0]); // add wall to left
        this.mTiles[i][this.mGridW - 1].addWall([1, 0]); // add wall to right
    }
}

/**
 * Enum for Directional values.
 * @readonly
 * @enum {array}
 */
Grid.eDirection = Object.freeze({
    eNorth: [0, 1],
    eEast: [1, 0],  
    eSouth: [0, -1],
    eWest: [-1, 0]
});

/**
 * Draws all tiles within the grid.
 * @param {Camera} cam - The camera object to draw the grid to.
 */
Grid.prototype.draw = function(cam) {
  for (var i = 0; i &lt; this.mGridH; i++) { // Col loop
    for (var j = 0; j &lt; this.mGridW; j++) { // Row loop
      var tile = this.mTiles[i][j];
      tile.draw(cam); // Will draw textures if visible, and edges if set to do so
    }
  }
};

/**
 * Sets all the visualize edge states of the tiles within the grid to given boolean value.
 * @param {boolean} bool - State to set the visualization of the edges of tiles to.
 */
Grid.prototype.setVisualizeEdges = function(bool) {
  for (var i = 0; i &lt; this.mGridH; i++) { // Col loop
    for (var j = 0; j &lt; this.mGridW; j++) { // Row loop
      var tile = this.mTiles[i][j];
      tile.setGridLineVisibility(bool);
    }
  }
};

// Setting all the edge visualization flags of the tiles to given bool
Grid.prototype.setVisualizeWalls = function(bool) {
  for (var i = 0; i &lt; this.mGridH; i++) { // Col loop
    for (var j = 0; j &lt; this.mGridW; j++) { // Row loop
      var tile = this.mTiles[i][j];
      tile.setWallVisibility(bool);
    }
  }
};

/**
 * Get the current width of tiles within the Grid in WC.
 * @returns {number} The width of all tiles in WC.
 */
Grid.prototype.getTileWidth = function() {
  return this.mTileW;
};

/**
 * Get the current height of tiles within the Grid in WC.
 * @returns {number} The height of all tiles in WC.
 */
Grid.prototype.getTileHeight = function() {
  return this.mTileH;
};

/**
 * Checks to see if a given WC is contained within the grid object.
 * @param {number} x - The x coordinate of the given WC position.
 * @param {number} y - The y coordinate of the given WC position.
 * @returns {boolean} True if given WC position lies within the Grid, false otherwise.
 */
Grid.prototype.isWCValidInGrid = function(x, y) {
  // This is a bit ugly, so I'm gonna condense it later.
  // For now, I just wanted to make the math on this easier to read. ✓
  if (x &lt; (this.mGridX - ((this.mGridW / 2) * this.mTileW))) {
      return false;
  } else if (x > (this.mGridX + ((this.mGridW / 2) * this.mTileW))) {
      return false;
  } else if (y &lt; (this.mGridY - ((this.mGridH / 2) * this.mTileH))) {
      return false;
  } else if (y > (this.mGridY + ((this.mGridH / 2) * this.mTileH))) {
      return false;
  }
  return true;
};

/**
 * Gets the index of the tile at the given WC.
 * @param {number} x - The x coordinate of the given WC position.
 * @param {number} y - The y coordinate of the given WC position.
 * @returns {array} The Grid index coordinate of the corresponding tile, [-1, -1] if given WC is not in the Grid.
 */
Grid.prototype.getTileAtWC = function(x, y) {
    // return -1, -1 if the WC is not in the grid
    if (!this.isWCValidInGrid(x, y)) {
        return [-1, -1];
    } else {
        // subtract the left bound of the grid from x
        x = x - (this.mGridX - ((this.mGridW / 2) * this.mTileW));
        // subtract the bottom bound of the grid form y
        y = y - (this.mGridY - ((this.mGridH / 2) * this.mTileH));
        
        // We need to do some error checking here, just to make sure
        // we don't return an invalid coordinate - cause guess what?
        // There is an exactly 1 (one) pixel wide/tall line where you
        // can get a coordinate larger than is actually contained in the grid. 
        var foundX = Math.min(this.mGridW - 1, Math.floor(x / this.mTileW));
        var foundY = Math.min(this.mGridH - 1, Math.floor(y / this.mTileH));
        
        return vec2.fromValues(foundX, foundY);
    }
};

/**
 * Gets the tile corresponding to the given index coordinate.
 * @param {number} x - The x coordinate of the desired Grid index coordinate.
 * @param {number} y - The y coordinate of the desired Grid index coordinate.
 * @returns {Tile} The tile object corresponding to the given index. Returns null if given invalid index.
 */
Grid.prototype.getTileAtIndex = function(x, y) {
  if (x >= 0 &amp;&amp; x &lt;= (this.mGridW - 1) &amp;&amp; y >= 0 &amp;&amp; y &lt;= (this.mGridH - 1)) {
    return this.mTiles[y][x];
  } else {
    return null;
  }
};


/**
 * Adds a wall of the given direction to the tile at the index shown. Also adds a wall to 
 * the tile the wall resides next to, so that the wall cannot be passed through in either direction.
 * @param {number} x - The x coordinate of the desired Grid index coordinate.
 * @param {number} y - The y coordinate of the desired Grid index coordinate.
 * @returns {boolean} True if the wall was able to be added, false otherwise.
 */
Grid.prototype.addWall = function(x, y, direction) {
  var initTile = this.getTileAtIndex(x, y);
  if (initTile === null) {
    return false;
  }

  var successful = initTile.addWall(direction);
  if (!successful) {
    return false;
  }

  var oppositeDir = [direction[0] * -1, direction[1] * -1];
  var nextTile = this.getTileAtIndex(x + direction[0], y + direction[1]);
  if (nextTile !== null) {
    nextTile.addWall(oppositeDir);
  }
  
  return true;
};


/**
 * Runs an A* Search algorithm given two Grid index positions within the grid to find the optimal 
 * path between them. Considers moving into collidable tiles &amp; through walls as invalid moves.
 * @param {} start -
 * @param {} finish -
 * @returns {array} An array of sequential moves to get to the desired position. Will be empty if 
 * a path was not found.
 */
Grid.prototype.AStarSearch = function(start, finish) {
    
    // clear any data from previous searches
    this.readySearch();
    
    // initialize search
    var openList = [];
    var visitedList = [];
    openList.push(start);
    
    while (openList.length > 0) {
        // find the tile in our list with the lowest combined
        // cost and heuristic score (we get this with getF())
        var bestIndex = 0;
        for (var i = 0; i &lt; openList.length; i++) {
            var tempTile = this.getTile(openList[bestIndex]);
            var tempTile2 = this.getTile(openList[i]);
            // find the lowest f score (f = cost + heuristic)
            if (tempTile.getF() > tempTile2.getF()) {
                bestIndex = i;
            }
        }
        // currentPos - cPos. Is a vec2 of a position in grid
        var cPos = openList[bestIndex];
        
        // if we've reached the end case, return the path found
        if (cPos[0] === finish[0] &amp;&amp; cPos[1] === finish[1]) {
            // get the direction from the parent
            var curr = cPos;
            var ret = [];
            var totalMoves = this.getTile(cPos).getC();
            for (var i = 0; i &lt; totalMoves; i++) {
                var dir = this.getTile(curr).getD();
                // push the direction from the tile
                ret.push(dir);
                // and move to the tiles parent
                curr = [curr[0] - dir[0], curr[1] - dir[1]];
            }
            // return the retrieved directions in reverse order
            return ret.reverse();
        }
        
        // remove currentTile from openList, and add to visited
        cPos = openList.splice(bestIndex, 1)[0];
        visitedList.push(cPos);
        var neighbors = this.getNeighbors(cPos);
        
        // now, go through all possible successors of current tile
        for (var i = 0; i &lt; neighbors.length; i++) {
            var neighbor =  neighbors[i];
            var nTile = this.getTile(neighbor);
            
            // don't bother examining if we haven't visited already
            var visitedAlready = false;
            for (var k = 0; k &lt; visitedList.length; k++) {
                var temp = visitedList[k];
                if (neighbor[0] === temp[0] &amp;&amp; neighbor[1] === temp[1]) {
                    visitedAlready = true;
                }
            }
            
            // if we haven't visited it before
            if (!visitedAlready) {
                var cScore = this.getTile(cPos).getC() + 1;
                var cScoreIsBest = false;
                var found = false;
                // determine if we've seen this node before
                for (var k = 0; k &lt; openList.length; k++) {
                    var temp = openList[k];
                    if (neighbor[0] === temp[0] &amp;&amp; neighbor[1] === temp[1]) {
                        found = true;
                    }
                }
                // if we have not seen this tile, add it to the openList
                if (!found) {
                    cScoreIsBest = true;
                    nTile.setH(this.manhattanDistance(neighbor, finish));
                    openList.push(neighbor);
                }
                else if (cScore &lt; nTile.getC()) {
                    // we've seen the node, but we have a better score
                    cScoreIsBest = true;
                }

                if (cScoreIsBest) {
                    // found an optimal path to the tile
                    nTile.setC(cScore);

                    // so, every tile stores the direction to it from the
                    // predecessor. so, grab the direction we took from
                    // the current tile.
                    nTile.setD([neighbor[0] - cPos[0], neighbor[1] - cPos[1]]);
                }
            }
        }
    }
    
    // if we've reached here, that means no path has been
    // found. return an empty array.
    return [];
};

/**
 * Helper function for A* search that resets data from any previous searches performed.
 */
Grid.prototype.readySearch = function() {
    for (var x = 0; x &lt; this.mGridW; x++) {
        for (var y = 0; y &lt; this.mGridH; y++) {
            this.mTiles[y][x].readySearch();
        }
    }
};

/**
 * Manhattan distance heuristic for A* search.
 * @param {array} pos1 - A position
 * @param {array} pos2 - A different position
 * @returns {number} Manhattan distance heuristic result 
 */
Grid.prototype.manhattanDistance = function(pos1, pos2) {
    return Math.abs(pos2[0] - pos1[0]) + Math.abs(pos2[1] - pos1[1]);
};

/**
 * A function used for grabbing the given position's neighboring tiles, based off of valid
 * movement from the given tile.
 * @param {array} curr - short for current position
 * @returns {array} containing neighboring tiles that can be reached from the given position
 */
Grid.prototype.getNeighbors = function(curr) {
    var ret = [];
    var cTile = this.getTile(curr);
    var moves = cTile.getMoves();
    for (var i = 0; i &lt; moves.length; i++) {
        var temp = vec2.fromValues(curr[0] + moves[i][0], curr[1] + moves[i][1]);
        ret.push(temp);
    }
    return ret;
};</code></pre>
        </article>
    </section>




</div>

<footer id="footer">
  
</footer>

<script src="scripts/third-party/prettify.js"></script>
<script src="scripts/third-party/lang-css.js"></script>
<script src="scripts/search.js"></script>
<script src="scripts/third-party/fuse.js"></script>
<script type="text/javascript" src="scripts/misc.js"></script>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
<script src="scripts/fix-code-block.js"></script>
<script>
  var list = [{"title":"Grid","link":"<a href=\"Grid.html\">Grid</a>"},{"title":"Grid#addObjectToGrid","link":"<a href=\"Grid.html#addObjectToGrid\">Grid &rtrif; addObjectToGrid</a>"},{"title":"Grid#addRangeWalls","link":"<a href=\"Grid.html#addRangeWalls\">Grid &rtrif; addRangeWalls</a>"},{"title":"Grid#addTileWall","link":"<a href=\"Grid.html#addTileWall\">Grid &rtrif; addTileWall</a>"},{"title":"Grid#addWall","link":"<a href=\"Grid.html#addWall\">Grid &rtrif; addWall</a>"},{"title":"Grid#addWallRange","link":"<a href=\"Grid.html#addWallRange\">Grid &rtrif; addWallRange</a>"},{"title":"Grid#AStarSearch","link":"<a href=\"Grid.html#AStarSearch\">Grid &rtrif; AStarSearch</a>"},{"title":"Grid#changeObjectPosition","link":"<a href=\"Grid.html#changeObjectPosition\">Grid &rtrif; changeObjectPosition</a>"},{"title":"Grid#draw","link":"<a href=\"Grid.html#draw\">Grid &rtrif; draw</a>"},{"title":"Grid#editRangeCollision","link":"<a href=\"Grid.html#editRangeCollision\">Grid &rtrif; editRangeCollision</a>"},{"title":"Grid#editRangeTexture","link":"<a href=\"Grid.html#editRangeTexture\">Grid &rtrif; editRangeTexture</a>"},{"title":"Grid#editRangeVisible","link":"<a href=\"Grid.html#editRangeVisible\">Grid &rtrif; editRangeVisible</a>"},{"title":"Grid#editTileCollision","link":"<a href=\"Grid.html#editTileCollision\">Grid &rtrif; editTileCollision</a>"},{"title":"Grid#editTileTexture","link":"<a href=\"Grid.html#editTileTexture\">Grid &rtrif; editTileTexture</a>"},{"title":"Grid#editTileVisible","link":"<a href=\"Grid.html#editTileVisible\">Grid &rtrif; editTileVisible</a>"},{"title":"Grid#getIDPosition","link":"<a href=\"Grid.html#getIDPosition\">Grid &rtrif; getIDPosition</a>"},{"title":"Grid#getNeighbors","link":"<a href=\"Grid.html#getNeighbors\">Grid &rtrif; getNeighbors</a>"},{"title":"Grid#getTileAtIndex","link":"<a href=\"Grid.html#getTileAtIndex\">Grid &rtrif; getTileAtIndex</a>"},{"title":"Grid#getTileAtWC","link":"<a href=\"Grid.html#getTileAtWC\">Grid &rtrif; getTileAtWC</a>"},{"title":"Grid#getTileHeight","link":"<a href=\"Grid.html#getTileHeight\">Grid &rtrif; getTileHeight</a>"},{"title":"Grid#getTileWidth","link":"<a href=\"Grid.html#getTileWidth\">Grid &rtrif; getTileWidth</a>"},{"title":"Grid#isWCValidInGrid","link":"<a href=\"Grid.html#isWCValidInGrid\">Grid &rtrif; isWCValidInGrid</a>"},{"title":"Grid#manhattanDistance","link":"<a href=\"Grid.html#manhattanDistance\">Grid &rtrif; manhattanDistance</a>"},{"title":"Grid#moveObjectPositionDir","link":"<a href=\"Grid.html#moveObjectPositionDir\">Grid &rtrif; moveObjectPositionDir</a>"},{"title":"Grid#readySearch","link":"<a href=\"Grid.html#readySearch\">Grid &rtrif; readySearch</a>"},{"title":"Grid#removeObjectFromGrid","link":"<a href=\"Grid.html#removeObjectFromGrid\">Grid &rtrif; removeObjectFromGrid</a>"},{"title":"Grid#removeTileWall","link":"<a href=\"Grid.html#removeTileWall\">Grid &rtrif; removeTileWall</a>"},{"title":"Grid#removeWallRange","link":"<a href=\"Grid.html#removeWallRange\">Grid &rtrif; removeWallRange</a>"},{"title":"Grid#setVisualizeEdges","link":"<a href=\"Grid.html#setVisualizeEdges\">Grid &rtrif; setVisualizeEdges</a>"},{"title":"Tile","link":"<a href=\"Tile.html\">Tile</a>"},{"title":"Tile#addWall","link":"<a href=\"Tile.html#addWall\">Tile &rtrif; addWall</a>"},{"title":"Tile#draw","link":"<a href=\"Tile.html#draw\">Tile &rtrif; draw</a>"},{"title":"Tile#getC","link":"<a href=\"Tile.html#getC\">Tile &rtrif; getC</a>"},{"title":"Tile#getCollision","link":"<a href=\"Tile.html#getCollision\">Tile &rtrif; getCollision</a>"},{"title":"Tile#getD","link":"<a href=\"Tile.html#getD\">Tile &rtrif; getD</a>"},{"title":"Tile#getF","link":"<a href=\"Tile.html#getF\">Tile &rtrif; getF</a>"},{"title":"Tile#getH","link":"<a href=\"Tile.html#getH\">Tile &rtrif; getH</a>"},{"title":"Tile#getMoves","link":"<a href=\"Tile.html#getMoves\">Tile &rtrif; getMoves</a>"},{"title":"Tile#getP","link":"<a href=\"Tile.html#getP\">Tile &rtrif; getP</a>"},{"title":"Tile#getWalls","link":"<a href=\"Tile.html#getWalls\">Tile &rtrif; getWalls</a>"},{"title":"Tile#getXPosWC","link":"<a href=\"Tile.html#getXPosWC\">Tile &rtrif; getXPosWC</a>"},{"title":"Tile#getYPosWC","link":"<a href=\"Tile.html#getYPosWC\">Tile &rtrif; getYPosWC</a>"},{"title":"Tile#hasP","link":"<a href=\"Tile.html#hasP\">Tile &rtrif; hasP</a>"},{"title":"Tile#isVisible","link":"<a href=\"Tile.html#isVisible\">Tile &rtrif; isVisible</a>"},{"title":"Tile#readySearch","link":"<a href=\"Tile.html#readySearch\">Tile &rtrif; readySearch</a>"},{"title":"Tile#removeWall","link":"<a href=\"Tile.html#removeWall\">Tile &rtrif; removeWall</a>"},{"title":"Tile#setC","link":"<a href=\"Tile.html#setC\">Tile &rtrif; setC</a>"},{"title":"Tile#setCollision","link":"<a href=\"Tile.html#setCollision\">Tile &rtrif; setCollision</a>"},{"title":"Tile#setD","link":"<a href=\"Tile.html#setD\">Tile &rtrif; setD</a>"},{"title":"Tile#setGridLineVisibility","link":"<a href=\"Tile.html#setGridLineVisibility\">Tile &rtrif; setGridLineVisibility</a>"},{"title":"Tile#setH","link":"<a href=\"Tile.html#setH\">Tile &rtrif; setH</a>"},{"title":"Tile#setP","link":"<a href=\"Tile.html#setP\">Tile &rtrif; setP</a>"},{"title":"Tile#setTexture","link":"<a href=\"Tile.html#setTexture\">Tile &rtrif; setTexture</a>"},{"title":"Tile#setVisible","link":"<a href=\"Tile.html#setVisible\">Tile &rtrif; setVisible</a>"},{"title":"Tile#setWallVisibility","link":"<a href=\"Tile.html#setWallVisibility\">Tile &rtrif; setWallVisibility</a>"}];
  var options = 
  setupSearch(list, options)
</script>

 






</body>
</html>
